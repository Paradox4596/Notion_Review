0619 영상 내용

----------------------------------------------------------------------------
----------------------------------------------------------------------------

Call By Reference
	-기본적으로는 함수 호출이 발생 할 때 argument가 parameter로 넘어가면서 복사가 일어나는데(Call By Value)
	주소 값을 넘겨줌으로써 parameter에 있는 값이 argument에 있는 값을 가리키게 만들 수 있다.
	
Static 변수의 특성 : 한번 만들어지면 끝까지 없어지지 않는다.
Dynamic " : 만들었다가 없애는 기능등이 자유자재

참조형은 C가 아닌 C++에서 업그레이드 된 포인터의 형태
	-참조형은 선언하는 동시에 반드시 초기화 해야한다.
	-초기화 이후에는 다른 변수를 가리킬 수 없다.
	--참조형은 매개변수로 많이 사용된다.

참조형은 기본적으로 const 포인터이기 때문에 가리키는 대상을 바꿀 수 없다.

const 참조형은 L-Value와 R-Value 개념을 알고 배워야 정확한 의미를 알 수 있다.

배열은 내부에서 포인터로 작동한다.

array + 1; 은 가능하지만, array++;은 불가능하다.
대입이 안된다->가리키는 값을 바꿀 수 없다->배열의 정체는 const pointer이다.
단, *p = array 일때 p++은 증감이 가능하다

위에서 배열은 내부에서 포인터로 작동한다고 했지만, C++에서 만들어진 타입으로 작동한다

----------------------------------------------------------------------------

int* (*(*p)(int))[10]

p
*
(int)
*
[10]
*
int

p is pointer to function parameter int return pointer to array 10 pointer to integer

----------------------------------------------------------------------------

int* (*(*arr[5])())();

arr
[5]
*
()
*
()
*
int

arr is
array 5
pointer to 
function returning // 매개변수가 없으면 그냥 이렇게 씀
pointer to
function returning
pointer to
integer

----------------------------------------------------------------------------

#include <iostream>


int main()
{
	char msg[6]{ "hello" };

	char* pMsg = msg;
	
	//아래 두 줄은 동일한 내용이다
	std::cout << msg << std::endl;
	std::cout << pMsg << std::endl;

	// r-value는 주소가 없으므로 틀린 문법
	char* p{ "hello" };
	// 이렇게 바꿔야 맞는다
	const char* p{ "hello" };
}

----------------------------------------------------------------------------

0620 영상 내용

----------------------------------------------------------------------------
----------------------------------------------------------------------------

	// 동적 메모리 할당 - C Style
	void* malloc(size_t size); // size_t
		Memory Allocation
		size : 할당할 메모리의 크기(byte)
		void* : 할당할 메모리의 포인터(주소)
		보이드 포인터의 특징!
			장점)아무거나 가리킬 수 있다.

			단점1)역참조 불가능
			단점2)연산 불가능  
			둘다 하나의 이야기 => 타입이 없기 때문에

	void* calloc(size_t num, size_t size);
	free(void* p);

----------------------------------------------------------------------------

#include <iostream>

int main()
{
	int* p = (int*)malloc(sizeof(int) * 3);
		
	if (p == nullptr)
	{
		return;
	}

	p[0] = 10;
	p[1] = 20;
	p[2] = 30;

	for (int i = 0; i < p[i]; i++)
	{
		std::cout << p[i] << std::endl;
	}

	free(p);

}

----------------------------------------------------------------------------

위 방법 보다 아래 방법이 더 확실하게 비주얼 스튜디오를 안심시킬 수 있음

----------------------------------------------------------------------------

#include <iostream>

int main()
{
	int* p = (int*)malloc(sizeof(int) * 3);
		
	if (p != nullptr)
	{
		p[0] = 10;
		p[1] = 20;
		p[2] = 30;

		for (int i = 0; i < p[i]; i++)
		{
			std::cout << p[i] << std::endl;
		}

		free(p);
	}
}

----------------------------------------------------------------------------

C++ 스타일이 훨씬 더 쉽고, 함수가 아닌 연산자이기 때문에 훨씬 더 빠르다

----------------------------------------------------------------------------

int* p = new int; // int* p{new int}; 와 동일
delete p;

int* p = new int[3];
delete[] p;

----------------------------------------------------------------------------

#include <iostream>

int main()
{
	int* p = new int[3] {};
	
	if (p != nullptr)
	{
		for (int i = 0; i < 3; i++)
		{
			std::cout << p[i] << std::endl;
		}

		delete[] p;
	}
}

----------------------------------------------------------------------------

!!!!!!!!!!!!!!!!!주의
1. Memory Leak(누수)
	할당은 했는데, 지우질 않음

	int *p = new int;
	delete p; // <-이거 바로 밑에 써놓고 시작하자! 안그러면 빼먹기 쉬움

2. new도 실패할 수 있습니다.
	언제? 메모리가 부족할 때..
	nullptr가 돌아옴

	어차피 안해도 메모리 부족하면 죽지 않느냐? -> ㄴㄴ 차이가 있다.
	게임하다 전조없이 확 꺼지기 vs. 메모리가 부족하다는 경고 문구 띄우고 꺼지기

	int* p = new int;
	
	if ( p != nullptr)
	{
	}

	if ( p )	// 바로 위와 동일한 표현이다.
	{
	}

3. Dangling Pointer
	int* p = new p;
	delete p;

	*p = 1;

	-------------------
	int* p = new p;
	delete p;
	p = nullptr;

<안전한 동적 메모리 할당의 예>
	int* p = new int;

	if( p )
	{
	///
	delete p;
	p = nullptr;
	}

----------------------------------------------------------------------------

앱이 실행될 때 메모리 구조

Code
	코드가 탑재(함수들...)
Data
	전역변수
Heap
	동적메모리가 할당
Register
	함수 호출 스택에 사용할 내부 정보
Stack
	지역변수
/// 이중에 Heap과 Stack이 중요하다

----------------------------------------------------------------------------

int main()
{
	// 4 * 1000000 = 4 MB
	int myArray[1000000]{};
}
/// Stack은 1메가 밖에 안되지만, Heap은 훨씬 더 크다

// 큰 데이터는 반드시 HEAP에 올려야함 -> 동적으로 할당

int* p = new int[1000000];
delete[] p;
